#+title: Advent of Code
#+author: Arian
#+startup: fold
#+description: My inconsistent advent of code solutions in various languages.

The [[https://raw.githubusercontent.com/Arian-D/aoc/export/README.pdf][PDF version]] is broken at the moment, but I'll fix it soon for
pwettier output.

* Day 1
** Emacs Lisp
- There's no built-in =sum= in lisp-land, so we can =apply= the =+= function.
- Here, I'm using =apply-partially= to somewhat simulate currying.
- Although =cl-reduce= requires the =cl= library, it's advantageous over
  =seq-reduce= because it does not require an initial item, thus making
  it suitable for =apply-partially=
#+begin_src emacs-lisp
  (defun sorted-calories (input-file)
    "Read the file and return a sorted list of elf item calories."
    (with-temp-buffer
      (insert-file-contents input-file)
      (let* ((file-content (buffer-string))
             (list (split-string file-content "\n\n"))
             (list-of-lists (mapcar
                             (lambda (list) (split-string list "\n"))
                             list))
             (parsed (mapcar (apply-partially #'mapcar
                                              #'string-to-number)
                             list-of-lists)) 
             (summed-up (mapcar (apply-partially #'cl-reduce #'+) parsed)))
        (sort summed-up #'>))))

  (let* ((sorted (sorted-calories "/tmp/input.txt"))
         (part-1-solution (car sorted))
         (part-2-solution
          (apply #'+ (seq-take sorted 3))))
    (print (list part-1-solution part-2-solution)))
#+end_src

** Haskell
- The function is [[https://wiki.haskell.org/Pointfree][point-free]] and simple compositions.
- This solution is inefficient because =sort= sorts items in ascending
  order and I =reverse= them. It gets the job done for this simple
  problem, but if I needed to make it more efficient I would've used
  the =sortBy= function instead and used a different =compare= to avoid reversing.
- I'll only mention it here because it's the first problem, but haskell offers lots of functions that
  offer richer types like =Maybe= and =Either= to do this in a more
  error-free manner in cases like parsing integers or reading files,
  but instead I just went with the ezâ„¢ solution.
#+begin_src haskell :results output
import Data.List (sort)
import Data.List.Split (splitOn)

sortedCalories :: String -> [Int]
sortedCalories =
    (reverse . sort . (map sum) . (map (map read)) . (splitOn [""]) . lines)

highest = head . sortedCalories

top3highest = sum . (take 3) . sortedCalories

main = do
  file <- readFile "/tmp/input.txt"
  -- Part 1 solution
  print . highest $ file
  -- Part 2 solution
  print . top3highest $ file
#+end_src

#  It doesn't look good (yet), but I'll either use minted for syntax
#  highlighting, or I'll be lazy and use ox-hugo. We'll see
